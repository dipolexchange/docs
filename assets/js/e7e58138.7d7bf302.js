"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[699],{3905:function(t,e,n){n.d(e,{Zo:function(){return m},kt:function(){return k}});var a=n(7294);function r(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function i(t,e){var n=Object.keys(t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(t);e&&(a=a.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),n.push.apply(n,a)}return n}function l(t){for(var e=1;e<arguments.length;e++){var n=null!=arguments[e]?arguments[e]:{};e%2?i(Object(n),!0).forEach((function(e){r(t,e,n[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(n,e))}))}return t}function o(t,e){if(null==t)return{};var n,a,r=function(t,e){if(null==t)return{};var n,a,r={},i=Object.keys(t);for(a=0;a<i.length;a++)n=i[a],e.indexOf(n)>=0||(r[n]=t[n]);return r}(t,e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(t);for(a=0;a<i.length;a++)n=i[a],e.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(t,n)&&(r[n]=t[n])}return r}var d=a.createContext({}),u=function(t){var e=a.useContext(d),n=e;return t&&(n="function"==typeof t?t(e):l(l({},e),t)),n},m=function(t){var e=u(t.components);return a.createElement(d.Provider,{value:e},t.children)},p={inlineCode:"code",wrapper:function(t){var e=t.children;return a.createElement(a.Fragment,{},e)}},s=a.forwardRef((function(t,e){var n=t.components,r=t.mdxType,i=t.originalType,d=t.parentName,m=o(t,["components","mdxType","originalType","parentName"]),s=u(n),k=r,N=s["".concat(d,".").concat(k)]||s[k]||p[k]||i;return n?a.createElement(N,l(l({ref:e},m),{},{components:n})):a.createElement(N,l({ref:e},m))}));function k(t,e){var n=arguments,r=e&&e.mdxType;if("string"==typeof t||r){var i=n.length,l=new Array(i);l[0]=s;var o={};for(var d in e)hasOwnProperty.call(e,d)&&(o[d]=e[d]);o.originalType=t,o.mdxType="string"==typeof t?t:r,l[1]=o;for(var u=2;u<i;u++)l[u]=n[u];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}s.displayName="MDXCreateElement"},3579:function(t,e,n){n.r(e),n.d(e,{assets:function(){return m},contentTitle:function(){return d},default:function(){return k},frontMatter:function(){return o},metadata:function(){return u},toc:function(){return p}});var a=n(7462),r=n(3366),i=(n(7294),n(3905)),l=["components"],o={id:"router",title:"Router",sidebar_position:2},d=void 0,u={unversionedId:"developers/smart-contract/router",id:"developers/smart-contract/router",title:"Router",description:"DipoleSwap is based on Uniswap v2. Read the Uniswap v2 documentation.\\",source:"@site/docs/developers/smart-contract/router.md",sourceDirName:"developers/smart-contract",slug:"/developers/smart-contract/router",permalink:"/docs/developers/smart-contract/router",editUrl:"https://github.com/dipolexchange/docs/tree/main/docs/developers/smart-contract/router.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{id:"router",title:"Router",sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Factory",permalink:"/docs/developers/smart-contract/factory"}},m={},p=[{value:"Contract info",id:"contract-info",level:2},{value:"Read functions",id:"read-functions",level:2},{value:"WETH",id:"weth",level:3},{value:"factory",id:"factory",level:3},{value:"getAmountOut",id:"getamountout",level:3},{value:"getAmountIn",id:"getamountin",level:3},{value:"getAmountsOut",id:"getamountsout",level:3},{value:"getAmountsIn",id:"getamountsin",level:3},{value:"quote",id:"quote",level:3},{value:"Write functions",id:"write-functions",level:2},{value:"addLiquidity",id:"addliquidity",level:3},{value:"addLiquidityETH",id:"addliquidityeth",level:3},{value:"removeLiquidity",id:"removeliquidity",level:3},{value:"removeLiquidityETH",id:"removeliquidityeth",level:3},{value:"removeLiquidityETHSupportingFeeOnTransferTokens",id:"removeliquidityethsupportingfeeontransfertokens",level:3},{value:"removeLiquidityETHWithPermit",id:"removeliquidityethwithpermit",level:3},{value:"removeLiquidityETHWithPermitSupportingFeeOnTransferTokens",id:"removeliquidityethwithpermitsupportingfeeontransfertokens",level:3},{value:"removeLiquidityWithPermit",id:"removeliquiditywithpermit",level:3},{value:"swapETHForExactTokens",id:"swapethforexacttokens",level:3},{value:"swapExactETHForTokens",id:"swapexactethfortokens",level:3},{value:"swapExactETHForTokensSupportingFeeOnTransferTokens",id:"swapexactethfortokenssupportingfeeontransfertokens",level:3},{value:"swapExactTokensForETH",id:"swapexacttokensforeth",level:3},{value:"swapExactTokensForETHSupportingFeeOnTransferTokens",id:"swapexacttokensforethsupportingfeeontransfertokens",level:3},{value:"swapExactTokensForTokens",id:"swapexacttokensfortokens",level:3},{value:"swapExactTokensForTokensSupportingFeeOnTransferTokens",id:"swapexacttokensfortokenssupportingfeeontransfertokens",level:3},{value:"swapTokensForExactETH",id:"swaptokensforexacteth",level:3},{value:"swapTokensForExactTokens",id:"swaptokensforexacttokens",level:3},{value:"Interface",id:"interface",level:2}],s={toc:p};function k(t){var e=t.components,n=(0,r.Z)(t,l);return(0,i.kt)("wrapper",(0,a.Z)({},s,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("div",{className:"admonition admonition-warning alert alert--danger"},(0,i.kt)("div",{parentName:"div",className:"admonition-heading"},(0,i.kt)("h5",{parentName:"div"},(0,i.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,i.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,i.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M5.05.31c.81 2.17.41 3.38-.52 4.31C3.55 5.67 1.98 6.45.9 7.98c-1.45 2.05-1.7 6.53 3.53 7.7-2.2-1.16-2.67-4.52-.3-6.61-.61 2.03.53 3.33 1.94 2.86 1.39-.47 2.3.53 2.27 1.67-.02.78-.31 1.44-1.13 1.81 3.42-.59 4.78-3.42 4.78-5.56 0-2.84-2.53-3.22-1.25-5.61-1.52.13-2.03 1.13-1.89 2.75.09 1.08-1.02 1.8-1.86 1.33-.67-.41-.66-1.19-.06-1.78C8.18 5.31 8.68 2.45 5.05.32L5.03.3l.02.01z"}))),"warning")),(0,i.kt)("div",{parentName:"div",className:"admonition-content"},(0,i.kt)("p",{parentName:"div"},"DipoleSwap is based on Uniswap v2. Read the ",(0,i.kt)("a",{parentName:"p",href:"https://docs.uniswap.org/protocol/V2/introduction"},"Uniswap v2 documentation"),".\\\nFor more in-depth information on the core contract logic, read the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/Uniswap/docs/blob/main/static/whitepaper.pdf"},"Uniswap v2 Core whitepaper"),"."))),(0,i.kt)("h2",{id:"contract-info"},"Contract info"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Contract name:")," DipoleRouter\n",(0,i.kt)("strong",{parentName:"p"},"Contract address:")," 0x78b674FBC75c43c3D91A35fFFA938268040C1990"),(0,i.kt)("p",null,"View the ",(0,i.kt)("a",{parentName:"p",href:"https://scan.platon.network/address-detail?address=0x78b674FBC75c43c3D91A35fFFA938268040C1990"},"DipoleSwap: Router v2 contract on PlatScan"),"."),(0,i.kt)("h2",{id:"read-functions"},"Read functions"),(0,i.kt)("h3",{id:"weth"},"WETH"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"function WETH() external pure returns (address);")),(0,i.kt)("p",null,"Returns the canonical address for ",(0,i.kt)("a",{parentName:"p",href:"https://scan.platon.network/contract-detail?address=0x02406D561069cBed27eF8Ea20AFD41779A90e2Bf"},"PlatON: WLAT token")," (WETH being a vestige from Ethereum network origins)."),(0,i.kt)("h3",{id:"factory"},"factory"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"function factory() external pure returns (address);")),(0,i.kt)("p",null,"Returns the canonical address for DipoleFactory."),(0,i.kt)("div",{className:"admonition admonition-warning alert alert--danger"},(0,i.kt)("div",{parentName:"div",className:"admonition-heading"},(0,i.kt)("h5",{parentName:"div"},(0,i.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,i.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,i.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M5.05.31c.81 2.17.41 3.38-.52 4.31C3.55 5.67 1.98 6.45.9 7.98c-1.45 2.05-1.7 6.53 3.53 7.7-2.2-1.16-2.67-4.52-.3-6.61-.61 2.03.53 3.33 1.94 2.86 1.39-.47 2.3.53 2.27 1.67-.02.78-.31 1.44-1.13 1.81 3.42-.59 4.78-3.42 4.78-5.56 0-2.84-2.53-3.22-1.25-5.61-1.52.13-2.03 1.13-1.89 2.75.09 1.08-1.02 1.8-1.86 1.33-.67-.41-.66-1.19-.06-1.78C8.18 5.31 8.68 2.45 5.05.32L5.03.3l.02.01z"}))),"warning")),(0,i.kt)("div",{parentName:"div",className:"admonition-content"},(0,i.kt)("p",{parentName:"div"},"For explanations of the following, view the ",(0,i.kt)("a",{parentName:"p",href:"https://uniswap.org/docs/v2/smart-contracts/library/#internal-functions"},"Uniswap v2 Internal Functions documentation"),"."))),(0,i.kt)("h3",{id:"getamountout"},"getAmountOut"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut);")),(0,i.kt)("h3",{id:"getamountin"},"getAmountIn"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) internal pure returns (uint amountIn);")),(0,i.kt)("h3",{id:"getamountsout"},"getAmountsOut"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"function getAmountsOut(uint amountIn, address[] memory path) internal view returns (uint[] memory amounts);")),(0,i.kt)("h3",{id:"getamountsin"},"getAmountsIn"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"function getAmountsIn(uint amountOut, address[] memory path) internal view returns (uint[] memory amounts);")),(0,i.kt)("h3",{id:"quote"},"quote"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"function quote(uint amountA, uint reserveA, uint reserveB) internal pure returns (uint amountB);")),(0,i.kt)("h2",{id:"write-functions"},"Write functions"),(0,i.kt)("h3",{id:"addliquidity"},"addLiquidity"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"function addLiquidity(\n  address tokenA,\n  address tokenB,\n  uint amountADesired,\n  uint amountBDesired,\n  uint amountAMin,\n  uint amountBMin,\n  address to,\n  uint deadline\n) external returns (uint amountA, uint amountB, uint liquidity);\n")),(0,i.kt)("p",null,"Adds liquidity to a PRC20\u21c4PRC20 pool."),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Name"),(0,i.kt)("th",{parentName:"tr",align:null},"Type"),(0,i.kt)("th",{parentName:"tr",align:null}))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"tokenA"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"address")),(0,i.kt)("td",{parentName:"tr",align:null},"The contract address of one token from your liquidity pair.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"tokenB"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"address")),(0,i.kt)("td",{parentName:"tr",align:null},"The contract address of the other token from your liquidity pair.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"amountADesired"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"uint")),(0,i.kt)("td",{parentName:"tr",align:null},"The amount of tokenA you'd like to provide as liquidity.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"amountBDesired"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"uint")),(0,i.kt)("td",{parentName:"tr",align:null},"The amount of tokenA you'd like to provide as liquidity.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"amountAMin"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"uint")),(0,i.kt)("td",{parentName:"tr",align:null},"The minimum amount of tokenA to provide (slippage impact).")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"amountBMin"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"uint")),(0,i.kt)("td",{parentName:"tr",align:null},"The minimum amount of tokenB to provide (slippage impact).")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"to"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"address")),(0,i.kt)("td",{parentName:"tr",align:null},"Address of LP Token recipient.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"deadline"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"uint")),(0,i.kt)("td",{parentName:"tr",align:null},"Unix timestamp deadline by which the transaction must confirm.")))),(0,i.kt)("h3",{id:"addliquidityeth"},"addLiquidityETH"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"function addLiquidityETH(\n  address token,\n  uint amountTokenDesired,\n  uint amountTokenMin,\n  uint amountETHMin,\n  address to,\n  uint deadline\n) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n")),(0,i.kt)("p",null,"Adds liquidity to a PRC20\u21c4WLAT pool."),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Name"),(0,i.kt)("th",{parentName:"tr",align:null},"Type"),(0,i.kt)("th",{parentName:"tr",align:null}))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"addLiquidityETH"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"uint")),(0,i.kt)("td",{parentName:"tr",align:null},"The payable amount in LAT.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"token"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"address")),(0,i.kt)("td",{parentName:"tr",align:null},"The contract address of the token to add liquidity.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"amountTokenDesired"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"uint")),(0,i.kt)("td",{parentName:"tr",align:null},"The amount of the token you'd like to provide as liquidity.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"amountTokenMin"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"uint")),(0,i.kt)("td",{parentName:"tr",align:null},"The minimum amount of the token to provide (slippage impact).")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"amountETHMin"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"uint")),(0,i.kt)("td",{parentName:"tr",align:null},"The minimum amount of LAT to provide (slippage impact).")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"to"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"address")),(0,i.kt)("td",{parentName:"tr",align:null},"Address of LP Token recipient.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"deadline"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"uint")),(0,i.kt)("td",{parentName:"tr",align:null},"Unix timestamp deadline by which the transaction must confirm.")))),(0,i.kt)("h3",{id:"removeliquidity"},"removeLiquidity"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"function removeLiquidity(\n  address tokenA,\n  address tokenB,\n  uint liquidity,\n  uint amountAMin,\n  uint amountBMin,\n  address to,\n  uint deadline\n) external returns (uint amountA, uint amountB);\n")),(0,i.kt)("p",null,"Removes liquidity from a PRC20\u21c4PRC20 pool."),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Name"),(0,i.kt)("th",{parentName:"tr",align:null},"Type"),(0,i.kt)("th",{parentName:"tr",align:null}))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"tokenA"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"address")),(0,i.kt)("td",{parentName:"tr",align:null},"The contract address of one token from your liquidity pair.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"tokenB"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"address")),(0,i.kt)("td",{parentName:"tr",align:null},"The contract address of the other token from your liquidity pair.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"liquidity"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"uint")),(0,i.kt)("td",{parentName:"tr",align:null},"The amount of LP Tokens to remove.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"amountAMin"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"uint")),(0,i.kt)("td",{parentName:"tr",align:null},"The minimum amount of tokenA to remove (slippage impact).")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"amountBMin"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"uint")),(0,i.kt)("td",{parentName:"tr",align:null},"The minimum amount of tokenB to remove (slippage impact).")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"to"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"address")),(0,i.kt)("td",{parentName:"tr",align:null},"Address of LP Token recipient.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"deadline"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"uint")),(0,i.kt)("td",{parentName:"tr",align:null},"Unix timestamp deadline by which the transaction must confirm.")))),(0,i.kt)("h3",{id:"removeliquidityeth"},"removeLiquidityETH"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"function removeLiquidityETH(\n  address token,\n  uint liquidity,\n  uint amountTokenMin,\n  uint amountETHMin,\n  address to,\n  uint deadline\n) external returns (uint amountToken, uint amountETH);\n")),(0,i.kt)("p",null,"Removes liquidity from a PRC20\u21c4WLAT pool."),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Name"),(0,i.kt)("th",{parentName:"tr",align:null},"Type"),(0,i.kt)("th",{parentName:"tr",align:null}))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"token"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"address")),(0,i.kt)("td",{parentName:"tr",align:null},"The contract address of the token to remove liquidity.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"liquidity"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"uint")),(0,i.kt)("td",{parentName:"tr",align:null},"The amount of LP Tokens to remove.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"amountTokenMin"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"uint")),(0,i.kt)("td",{parentName:"tr",align:null},"The minimum amount of the token to remove (slippage impact).")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"amountETHMin"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"uint")),(0,i.kt)("td",{parentName:"tr",align:null},"The minimum amount of LAT to remove (slippage impact).")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"to"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"address")),(0,i.kt)("td",{parentName:"tr",align:null},"Address of LP Token recipient.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"deadline"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"uint")),(0,i.kt)("td",{parentName:"tr",align:null},"Unix timestamp deadline by which the transaction must confirm.")))),(0,i.kt)("h3",{id:"removeliquidityethsupportingfeeontransfertokens"},"removeLiquidityETHSupportingFeeOnTransferTokens"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"function removeLiquidityETHSupportingFeeOnTransferTokens(\n  address token,\n  uint liquidity,\n  uint amountTokenMin,\n  uint amountETHMin,\n  address to,\n  uint deadline\n) external returns (uint amountETH);\n")),(0,i.kt)("p",null,"Removes liquidity from a PRC20\u21c4WLAT for tokens that take a fee on transfer."),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Name"),(0,i.kt)("th",{parentName:"tr",align:null},"Type"),(0,i.kt)("th",{parentName:"tr",align:null}))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"token"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"address")),(0,i.kt)("td",{parentName:"tr",align:null},"The contract address of the token to remove liquidity.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"liquidity"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"uint")),(0,i.kt)("td",{parentName:"tr",align:null},"The amount of LP Tokens to remove.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"amountTokenMin"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"uint")),(0,i.kt)("td",{parentName:"tr",align:null},"The minimum amount of the token to remove (slippage impact).")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"amountETHMin"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"uint")),(0,i.kt)("td",{parentName:"tr",align:null},"The minimum amount of LAT to remove (slippage impact).")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"to"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"address")),(0,i.kt)("td",{parentName:"tr",align:null},"Address of LP Token recipient.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"deadline"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"uint")),(0,i.kt)("td",{parentName:"tr",align:null},"Unix timestamp deadline by which the transaction must confirm.")))),(0,i.kt)("h3",{id:"removeliquidityethwithpermit"},"removeLiquidityETHWithPermit"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"function removeLiquidityETHWithPermit(\n  address token,\n  uint liquidity,\n  uint amountTokenMin,\n  uint amountETHMin,\n  address to,\n  uint deadline,\n  bool approveMax, uint8 v, bytes32 r, bytes32 s\n) external returns (uint amountToken, uint amountETH);\n")),(0,i.kt)("p",null,"Removes liquidity from a PRC20\u21c4WLAT and receives LAT, without pre-approval, via permit."),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Name"),(0,i.kt)("th",{parentName:"tr",align:null},"Type"),(0,i.kt)("th",{parentName:"tr",align:null}))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"token"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"address")),(0,i.kt)("td",{parentName:"tr",align:null},"The contract address of the token to remove liquidity.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"liquidity"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"uint")),(0,i.kt)("td",{parentName:"tr",align:null},"The amount of LP Tokens to remove.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"amountTokenMin"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"uint")),(0,i.kt)("td",{parentName:"tr",align:null},"The minimum amount of the token to remove (slippage impact).")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"amountETHMin"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"uint")),(0,i.kt)("td",{parentName:"tr",align:null},"The minimum amount of LAT to remove (slippage impact).")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"to"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"address")),(0,i.kt)("td",{parentName:"tr",align:null},"Address of LP Token recipient.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"deadline"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"uint")),(0,i.kt)("td",{parentName:"tr",align:null},"Unix timestamp deadline by which the transaction must confirm.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"approveMax"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"bool")),(0,i.kt)("td",{parentName:"tr",align:null},"Whether or not the approval amount in the signature is for liquidity or ",(0,i.kt)("inlineCode",{parentName:"td"},"uint(-1)"),".")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"v"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"uint8")),(0,i.kt)("td",{parentName:"tr",align:null},"The v component of the permit signature.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"r"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"bytes32")),(0,i.kt)("td",{parentName:"tr",align:null},"The r component of the permit signature.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"s"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"bytes32")),(0,i.kt)("td",{parentName:"tr",align:null},"The s component of the permit signature.")))),(0,i.kt)("h3",{id:"removeliquidityethwithpermitsupportingfeeontransfertokens"},"removeLiquidityETHWithPermitSupportingFeeOnTransferTokens"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n  address token,\n  uint liquidity,\n  uint amountTokenMin,\n  uint amountETHMin,\n  address to,\n  uint deadline,\n  bool approveMax, uint8 v, bytes32 r, bytes32 s\n) external returns (uint amountETH);\n")),(0,i.kt)("p",null,"Removes liquidity from a PRC20\u21c4WLAT and receives LAT via permit for tokens that take a fee on transfer."),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Name"),(0,i.kt)("th",{parentName:"tr",align:null},"Type"),(0,i.kt)("th",{parentName:"tr",align:null}))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"token"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"address")),(0,i.kt)("td",{parentName:"tr",align:null},"The contract address of the token to remove liquidity.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"liquidity"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"uint")),(0,i.kt)("td",{parentName:"tr",align:null},"The amount of LP Tokens to remove.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"amountTokenMin"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"uint")),(0,i.kt)("td",{parentName:"tr",align:null},"The minimum amount of the token to remove (slippage impact).")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"amountETHMin"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"uint")),(0,i.kt)("td",{parentName:"tr",align:null},"The minimum amount of LAT to remove (slippage impact).")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"to"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"address")),(0,i.kt)("td",{parentName:"tr",align:null},"Address of LP Token recipient.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"deadline"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"uint")),(0,i.kt)("td",{parentName:"tr",align:null},"Unix timestamp deadline by which the transaction must confirm.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"approveMax"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"bool")),(0,i.kt)("td",{parentName:"tr",align:null},"Whether or not the approval amount in the signature is for liquidity or ",(0,i.kt)("inlineCode",{parentName:"td"},"uint(-1)"),".")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"v"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"uint8")),(0,i.kt)("td",{parentName:"tr",align:null},"The v component of the permit signature.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"r"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"bytes32")),(0,i.kt)("td",{parentName:"tr",align:null},"The r component of the permit signature.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"s"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"bytes32")),(0,i.kt)("td",{parentName:"tr",align:null},"The s component of the permit signature.")))),(0,i.kt)("h3",{id:"removeliquiditywithpermit"},"removeLiquidityWithPermit"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"function removeLiquidityWithPermit(\n  address tokenA,\n  address tokenB,\n  uint liquidity,\n  uint amountAMin,\n  uint amountBMin,\n  address to,\n  uint deadline,\n  bool approveMax, uint8 v, bytes32 r, bytes32 s\n) external returns (uint amountA, uint amountB);\n")),(0,i.kt)("p",null,"Removes liquidity from a PRC20\u21c4PRC20, without pre-approval, via permit."),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Name"),(0,i.kt)("th",{parentName:"tr",align:null},"Type"),(0,i.kt)("th",{parentName:"tr",align:null}))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"tokenA"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"address")),(0,i.kt)("td",{parentName:"tr",align:null},"The contract address of one token from your liquidity pair.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"tokenB"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"address")),(0,i.kt)("td",{parentName:"tr",align:null},"The contract address of the other token from your liquidity pair.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"liquidity"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"uint")),(0,i.kt)("td",{parentName:"tr",align:null},"The amount of LP Tokens to remove.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"amountTokenMin"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"uint")),(0,i.kt)("td",{parentName:"tr",align:null},"The minimum amount of the token to remove (slippage impact).")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"amountETHMin"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"uint")),(0,i.kt)("td",{parentName:"tr",align:null},"The minimum amount of LAT to remove (slippage impact).")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"to"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"address")),(0,i.kt)("td",{parentName:"tr",align:null},"Address of LP Token recipient.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"deadline"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"uint")),(0,i.kt)("td",{parentName:"tr",align:null},"Unix timestamp deadline by which the transaction must confirm.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"approveMax"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"bool")),(0,i.kt)("td",{parentName:"tr",align:null},"Whether or not the approval amount in the signature is for liquidity or ",(0,i.kt)("inlineCode",{parentName:"td"},"uint(-1)"),".")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"v"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"uint8")),(0,i.kt)("td",{parentName:"tr",align:null},"The v component of the permit signature.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"r"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"bytes32")),(0,i.kt)("td",{parentName:"tr",align:null},"The r component of the permit signature.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"s"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"bytes32")),(0,i.kt)("td",{parentName:"tr",align:null},"The s component of the permit signature.")))),(0,i.kt)("h3",{id:"swapethforexacttokens"},"swapETHForExactTokens"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n  external\n  payable\n  returns (uint[] memory amounts);\n")),(0,i.kt)("p",null,"Receive an exact amount of output tokens for as little LAT as possible."),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Name"),(0,i.kt)("th",{parentName:"tr",align:null},"Type"),(0,i.kt)("th",{parentName:"tr",align:null}))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"swapETHForExactTokens"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"uint")),(0,i.kt)("td",{parentName:"tr",align:null},"Payable LAT amount.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"amountOut"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"uint")),(0,i.kt)("td",{parentName:"tr",align:null},"The amount tokens to receive.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"path (address","[","])"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"address")),(0,i.kt)("td",{parentName:"tr",align:null},"An array of token addresses. ",(0,i.kt)("inlineCode",{parentName:"td"},"path.length")," must be >= 2. Pools for each consecutive pair of addresses must exist and have liquidity.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"to"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"address")),(0,i.kt)("td",{parentName:"tr",align:null},"Address of recipient.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"deadline"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"uint")),(0,i.kt)("td",{parentName:"tr",align:null},"Unix timestamp deadline by which the transaction must confirm.")))),(0,i.kt)("h3",{id:"swapexactethfortokens"},"swapExactETHForTokens"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n  external\n  payable\n  returns (uint[] memory amounts);\n")),(0,i.kt)("p",null,"Receive as many output tokens as possible for an exact amount of LAT."),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Name"),(0,i.kt)("th",{parentName:"tr",align:null},"Type"),(0,i.kt)("th",{parentName:"tr",align:null}))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"swapExactETHForTokens"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"uint")),(0,i.kt)("td",{parentName:"tr",align:null},"Payable LAT amount.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"amountOutMin"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"uint")),(0,i.kt)("td",{parentName:"tr",align:null},"The minimum amount tokens to receive.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"path (address","[","])"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"address")),(0,i.kt)("td",{parentName:"tr",align:null},"An array of token addresses. ",(0,i.kt)("inlineCode",{parentName:"td"},"path.length")," must be >= 2. Pools for each consecutive pair of addresses must exist and have liquidity.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"to"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"address")),(0,i.kt)("td",{parentName:"tr",align:null},"Address of recipient.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"deadline"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"uint")),(0,i.kt)("td",{parentName:"tr",align:null},"Unix timestamp deadline by which the transaction must confirm.")))),(0,i.kt)("h3",{id:"swapexactethfortokenssupportingfeeontransfertokens"},"swapExactETHForTokensSupportingFeeOnTransferTokens"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"function swapExactETHForTokensSupportingFeeOnTransferTokens(\n  uint amountOutMin,\n  address[] calldata path,\n  address to,\n  uint deadline\n) external payable;\n")),(0,i.kt)("p",null,"Receive as many output tokens as possible for an exact amount of LAT. Supports tokens that take a fee on transfer."),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Name"),(0,i.kt)("th",{parentName:"tr",align:null},"Type"),(0,i.kt)("th",{parentName:"tr",align:null}))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"swapExactETHForTokensSupportingFeeOnTransferTokens"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"uint")),(0,i.kt)("td",{parentName:"tr",align:null},"Payable LAT amount.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"amountOutMin"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"uint")),(0,i.kt)("td",{parentName:"tr",align:null},"The minimum amount tokens to receive.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"path (address","[","])"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"address")),(0,i.kt)("td",{parentName:"tr",align:null},"An array of token addresses. ",(0,i.kt)("inlineCode",{parentName:"td"},"path.length")," must be >= 2. Pools for each consecutive pair of addresses must exist and have liquidity.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"to"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"address")),(0,i.kt)("td",{parentName:"tr",align:null},"Address of recipient.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"deadline"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"uint")),(0,i.kt)("td",{parentName:"tr",align:null},"Unix timestamp deadline by which the transaction must confirm.")))),(0,i.kt)("h3",{id:"swapexacttokensforeth"},"swapExactTokensForETH"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n  external\n  returns (uint[] memory amounts);\n")),(0,i.kt)("p",null,"Receive as much LAT as possible for an exact amount of input tokens."),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Name"),(0,i.kt)("th",{parentName:"tr",align:null},"Type"),(0,i.kt)("th",{parentName:"tr",align:null}))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"amountIn"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"uint")),(0,i.kt)("td",{parentName:"tr",align:null},"Payable amount of input tokens.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"amountOutMin"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"uint")),(0,i.kt)("td",{parentName:"tr",align:null},"The minimum amount tokens to receive.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"path (address","[","])"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"address")),(0,i.kt)("td",{parentName:"tr",align:null},"An array of token addresses. ",(0,i.kt)("inlineCode",{parentName:"td"},"path.length")," must be >= 2. Pools for each consecutive pair of addresses must exist and have liquidity.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"to"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"address")),(0,i.kt)("td",{parentName:"tr",align:null},"Address of recipient.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"deadline"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"uint")),(0,i.kt)("td",{parentName:"tr",align:null},"Unix timestamp deadline by which the transaction must confirm.")))),(0,i.kt)("h3",{id:"swapexacttokensforethsupportingfeeontransfertokens"},"swapExactTokensForETHSupportingFeeOnTransferTokens"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"function swapExactTokensForETHSupportingFeeOnTransferTokens(\n  uint amountIn,\n  uint amountOutMin,\n  address[] calldata path,\n  address to,\n  uint deadline\n) external;\n")),(0,i.kt)("p",null,"Receive as much LAT as possible for an exact amount of tokens. Supports tokens that take a fee on transfer."),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Name"),(0,i.kt)("th",{parentName:"tr",align:null},"Type"),(0,i.kt)("th",{parentName:"tr",align:null}))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"amountIn"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"uint")),(0,i.kt)("td",{parentName:"tr",align:null},"Payable amount of input tokens.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"amountOutMin"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"uint")),(0,i.kt)("td",{parentName:"tr",align:null},"The minimum amount tokens to receive.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"path (address","[","])"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"address")),(0,i.kt)("td",{parentName:"tr",align:null},"An array of token addresses. ",(0,i.kt)("inlineCode",{parentName:"td"},"path.length")," must be >= 2. Pools for each consecutive pair of addresses must exist and have liquidity.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"to"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"address")),(0,i.kt)("td",{parentName:"tr",align:null},"Address of recipient.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"deadline"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"uint")),(0,i.kt)("td",{parentName:"tr",align:null},"Unix timestamp deadline by which the transaction must confirm.")))),(0,i.kt)("h3",{id:"swapexacttokensfortokens"},"swapExactTokensForTokens"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"function swapExactTokensForTokens(\n  uint amountIn,\n  uint amountOutMin,\n  address[] calldata path,\n  address to,\n  uint deadline\n) external returns (uint[] memory amounts);\n")),(0,i.kt)("p",null,"Receive as many output tokens as possible for an exact amount of input tokens."),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Name"),(0,i.kt)("th",{parentName:"tr",align:null},"Type"),(0,i.kt)("th",{parentName:"tr",align:null}))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"amountIn"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"uint")),(0,i.kt)("td",{parentName:"tr",align:null},"Payable amount of input tokens.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"amountOutMin"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"uint")),(0,i.kt)("td",{parentName:"tr",align:null},"The minimum amount tokens to receive.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"path (address","[","])"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"address")),(0,i.kt)("td",{parentName:"tr",align:null},"An array of token addresses. ",(0,i.kt)("inlineCode",{parentName:"td"},"path.length")," must be >= 2. Pools for each consecutive pair of addresses must exist and have liquidity.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"to"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"address")),(0,i.kt)("td",{parentName:"tr",align:null},"Address of recipient.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"deadline"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"uint")),(0,i.kt)("td",{parentName:"tr",align:null},"Unix timestamp deadline by which the transaction must confirm.")))),(0,i.kt)("h3",{id:"swapexacttokensfortokenssupportingfeeontransfertokens"},"swapExactTokensForTokensSupportingFeeOnTransferTokens"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n  uint amountIn,\n  uint amountOutMin,\n  address[] calldata path,\n  address to,\n  uint deadline\n) external;\n")),(0,i.kt)("p",null,"Receive as many output tokens as possible for an exact amount of input tokens. Supports tokens that take a fee on transfer."),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Name"),(0,i.kt)("th",{parentName:"tr",align:null},"Type"),(0,i.kt)("th",{parentName:"tr",align:null}))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"amountIn"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"uint")),(0,i.kt)("td",{parentName:"tr",align:null},"Payable amount of input tokens.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"amountOutMin"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"uint")),(0,i.kt)("td",{parentName:"tr",align:null},"The minimum amount tokens to receive.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"path (address","[","])"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"address")),(0,i.kt)("td",{parentName:"tr",align:null},"An array of token addresses. ",(0,i.kt)("inlineCode",{parentName:"td"},"path.length")," must be >= 2. Pools for each consecutive pair of addresses must exist and have liquidity.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"to"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"address")),(0,i.kt)("td",{parentName:"tr",align:null},"Address of recipient.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"deadline"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"uint")),(0,i.kt)("td",{parentName:"tr",align:null},"Unix timestamp deadline by which the transaction must confirm.")))),(0,i.kt)("h3",{id:"swaptokensforexacteth"},"swapTokensForExactETH"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n  external\n  returns (uint[] memory amounts);\n")),(0,i.kt)("p",null,"Receive an exact amount of ETH for as few input tokens as possible."),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Name"),(0,i.kt)("th",{parentName:"tr",align:null},"Type"),(0,i.kt)("th",{parentName:"tr",align:null}))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"amountOut"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"uint")),(0,i.kt)("td",{parentName:"tr",align:null},"Payable amount of input tokens.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"amountInMax"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"uint")),(0,i.kt)("td",{parentName:"tr",align:null},"The minimum amount tokens to input.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"path (address","[","])"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"address")),(0,i.kt)("td",{parentName:"tr",align:null},"An array of token addresses. ",(0,i.kt)("inlineCode",{parentName:"td"},"path.length")," must be >= 2. Pools for each consecutive pair of addresses must exist and have liquidity.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"to"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"address")),(0,i.kt)("td",{parentName:"tr",align:null},"Address of recipient.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"deadline"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"uint")),(0,i.kt)("td",{parentName:"tr",align:null},"Unix timestamp deadline by which the transaction must confirm.")))),(0,i.kt)("h3",{id:"swaptokensforexacttokens"},"swapTokensForExactTokens"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"function swapTokensForExactTokens(\n  uint amountOut,\n  uint amountInMax,\n  address[] calldata path,\n  address to,\n  uint deadline\n) external returns (uint[] memory amounts);\n")),(0,i.kt)("p",null,"Receive an exact amount of output tokens for as few input tokens as possible."),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Name"),(0,i.kt)("th",{parentName:"tr",align:null},"Type"),(0,i.kt)("th",{parentName:"tr",align:null}))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"amountOut"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"uint")),(0,i.kt)("td",{parentName:"tr",align:null},"Payable amount of input tokens.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"amountInMax"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"uint")),(0,i.kt)("td",{parentName:"tr",align:null},"The minimum amount tokens to input.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"path (address","[","])"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"address")),(0,i.kt)("td",{parentName:"tr",align:null},"An array of token addresses. ",(0,i.kt)("inlineCode",{parentName:"td"},"path.length")," must be >= 2. Pools for each consecutive pair of addresses must exist and have liquidity.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"to"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"address")),(0,i.kt)("td",{parentName:"tr",align:null},"Address of recipient.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"deadline"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"uint")),(0,i.kt)("td",{parentName:"tr",align:null},"Unix timestamp deadline by which the transaction must confirm.")))),(0,i.kt)("h2",{id:"interface"},"Interface"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"pragma solidity >=0.6.2;\ninterface IDipoleRouter01 {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n}\n// File: contracts\\interfaces\\IDipoleRouter02.sol\npragma solidity >=0.6.2;\ninterface IDipoleRouter02 is IDipoleRouter01 {\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountETH);\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountETH);\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n}\n")))}k.isMDXComponent=!0}}]);